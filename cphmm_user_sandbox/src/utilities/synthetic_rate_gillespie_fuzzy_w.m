function gillespie = synthetic_rate_gillespie_fuzzy_w(seq_length, alpha, ...
                                K, w_mean, w_sigma, R, deltaT, r_emission, noise, pi0, f_rna)

    % Generates a fluorescence sequence for the given model parameters
    % using the Gillespie algorithm to simulated stochastic promoter 
    % switching. Assumes normally distributed PolII elongation time 
    % 
    % INPUTS
    % seq_length: length of the sequence in time steps
    % alpha: length of the MS2 loop in time steps
    % K: number of naive states
    % w_mean: mean memory
    % w_sigma: standard deviation in memory
    % R: transition rate matrix [sec^{-1}]
    % deltaT: time resolution [sec]
    % r_emission: emission rates [sec^{-1}]
    % noise: Gaussian noise [a.u.]
    % pi0: initial state probability mass function (pmf)
    % f_rna: fluorescence per mRNA
    % 
    % OUTPUTS
    % gillespie: structure that contains the synthetic data info    
    %   .fluo_MS2: synthetic trace generated by taking the MS2 loops 
    %              into account
    %   .fluo_MS2_fuzzy: synthetic trace generated by taking the MS2 loops 
    %              into account with normally distributed w    
    %   .fluo_MS2_no_noise: synthetic trace generating by taking the MS2 
    %                       loops into account but with no Gaussian noise
    %   .fluo_MS2_fuzzy_no_noise: synthetic trace generating by taking the MS2 
    %                       loops into account but with no Gaussian noise
    %   .transition_times: times when the transitions happened
    %   .transition_count: number of transitions in the simulated trace
    %   .naive_states: sequence of the naive states of the system at time
    %                  moments specified in the variable 'times'
    %   .arrival_times: times of initiation events
    
    % uniformly distributed time points with resolution deltaT 
    % and length seq_length
    times_unif = (1:seq_length) * deltaT;
    % calculate arrival rate for PolII
    arrival_rates = r_emission / f_rna;
    term_time_mean = w_mean*deltaT;
    term_time_sigma = w_sigma*deltaT;
    % fluorescence sequence at time points 'time_unif' when the effect of
    % the MS2 loops is taken into account
    fluo_MS2 = zeros(1, seq_length);
    fluo_MS2_fuzzy = zeros(1, seq_length);
    
    % arrays for storing the naive states, times of transitions and 
    % cumulative fluorescence values during the Gillespie simulation
    naive_states = [];
    promoter_times = [];
    fluo_cum = [];
    
    % duration of the simulated process
    t_max = seq_length * deltaT;
    
    % first state obtained by sampling the initial state pmf
    naive_states(1) = randsample(1:K, 1, true, pi0);
    
    % assign 0 values to the time and fluo_cum arrays at t = 0
    promoter_times(1) = 0;
    fluo_cum(1) = 0;
    
    % variable to keep track of the current reaction time
    t = 0;
    
    % indexing variable to keep track of the current transition
    ind = 1;
    
    % generate a sequence of naive states using the Gillespie algorithm
    while (t < t_max)
        
        lambda = -R(naive_states(ind),naive_states(ind));
        dt = exprnd(1/lambda);
        t = t + dt;
        
        rates = R(:,naive_states(ind));
        rates(naive_states(ind)) = 0;
        
        probs = rates / lambda;
        
        naive_states(ind + 1) = randsample(1:K, 1, true, probs);
        ind = ind + 1;
        promoter_times(ind) = t;
        
        fluo_cum(ind) = fluo_cum(ind-1) + (promoter_times(ind) - promoter_times(ind-1)) * ...
            r_emission(naive_states(ind - 1));
    end
    
    % number of transitions in the simulated trace
    transition_count = ind-1;    
    % simulate loading events and termination events
    % assume loading to be effectively deterministic
    % assume termination to be normally distributed
    arrival_times = []; % Track Event Times
    termination_times = []; % Track termination times
    for t = 2:length(promoter_times)
        ts = promoter_times(t-1);
        tf = promoter_times(t);
        ns = naive_states(t-1);
        lambda = arrival_rates(ns);
        if lambda == 0
            continue
        end
        n_arrivals = round((tf-ts)*lambda);
        time_grid = (0:(n_arrivals-1))/lambda;
        padding = tf - ts - (n_arrivals-1)/lambda;
        time_grid = time_grid + padding/2 + ts;
        if max(time_grid) > tf
            error('time indexing error')
        end
        for ta = time_grid            
            arrival_times = [arrival_times ta];
            % draw termination times from truncated norm (no negative
            % term times)
            U=normcdf(2*term_time_mean,term_time_mean,term_time_sigma);                
            X=rand();
            term_time= 2*term_time_mean - norminv(X*U,term_time_mean,term_time_sigma);
            termination_times = [termination_times ta + term_time];            
        end
    end
    % find the fluorescence at the uniformly distributed points without
    % accounting for the MS2 loops
%     fluo_cum_interp = interp1(times, fluo_cum, times_unif);
%     fluo_cum_interp_shift = [zeros([1, w]), fluo_cum_interp(1:(end-w))];
%     fluo = fluo_cum_interp - fluo_cum_interp_shift;
%     
    % find the fluorescence at the uniformly distributed points taking the
    % MS2 loops into account
    for k = 1:seq_length
        t_end = times_unif(k);
        t_start = max([0, t_end - w_mean*deltaT]);
        
        ind_start_before = find(promoter_times <= t_start);
        i_start = ind_start_before(end);
        
        ind_end_before = find(promoter_times <= t_end);
        i_end = ind_end_before(end);
        
        times_window = promoter_times(i_start:(i_end+1));
        times_window(1) = t_start;
        times_window(end) = t_end;
        
        naive_window = naive_states(i_start:(i_end+1));
        
        for i = 1:(length(naive_window)-1)            
            t1 = t_end - times_window(i+1);
            t2 = t_end - times_window(i);
            fluo_MS2(k) = fluo_MS2(k) + r_emission(naive_window(i)) * ...
                          ms2_loading_coeff_integral(alpha, w_mean, deltaT, t1, t2);
        end
    end
    % Now for Poisson
    for k = 1:seq_length
        t_end = times_unif(k);        
        extant_polII = find((termination_times>t_end)&(arrival_times<=t_end));      
        if isempty(extant_polII)
            continue;
        end     
        times_window = arrival_times(extant_polII);
        for g = 1:(length(times_window))

            t2 = t_end - times_window(g);
            if t2 > alpha * deltaT
                fluo_MS2_fuzzy(k) = fluo_MS2_fuzzy(k) + f_rna;
            else
                fluo_MS2_fuzzy(k) = fluo_MS2_fuzzy(k) + f_rna * ...
                          t2 / (alpha * deltaT);
            end
        end
    end

    % Gaussian noise
    gauss_noise = normrnd(0,noise,1,seq_length);
    
    % add a Gaussian noise
    fluo_MS2_fuzzy_noise = fluo_MS2_fuzzy + gauss_noise;
    fluo_MS2_noise = fluo_MS2 + gauss_noise;
    
    % the output structure
    gillespie = struct('fluo_MS2_fuzzy', fluo_MS2_fuzzy_noise, 'fluo_MS2', fluo_MS2_noise, ...
        'fluo_MS2_fuzzy_no_noise', fluo_MS2_fuzzy, 'fluo_MS2_no_noise', fluo_MS2, ...
        'transition_times', promoter_times, 'transition_count', transition_count, ...
        'naive_states', naive_states, 'arrival_times',arrival_times,'termination_times',termination_times,...
        'dwell_times',termination_times - arrival_times);