function gillespie = synthetic_rate_gillespie_semi_poisson_multi(seq_length, alpha, ...
                                K, w, R, deltaT, r_emission, noise, pi0, ...
                                blocking_sizes, elongation_rates, fluo_per_rna,...
                                n_promoters, instant_fluo, names, adjust_means)

    % Generates a fluorescence sequence for the given model parameters
    % using the Gillespie algorithm. Seeks to account for impact of finite 
    % PolII elongation rates and stochastic arrival times
    
    % INPUTS
    % seq_length: length of the sequence in time steps
    % alpha: length of the MS2 loop in time steps
    % K: number of naive states
    % w: memory
    % R: transition rate matrix [sec^{-1}]
    % deltaT: time resolution [sec]
    % r_emission: emission rates [A.U. * sec^{-1}]
    % noise: Gaussian noise [a.u.]
    % pi0: initial state probability mass function (pmf)
    % blocking_sizs: vector giving num bp previous PolII must clear for next to load
    % elongation rates: vector of rates of PolII traversal (bp/s)
    % arival_rate: vector of rate of PollII arrival to initiation area
    % n_promoters: 1 or 2 active promoters
    % instant_fluo: binary vector. if 1, PolII loading is taken to occur instantaneously
    % adjust_means: binary. if fluo_per_rna for each test will be
    %               calibrated after the fact to adjust for discrete effects on mean fluo
    %
    % OUTPUTS
    % gillespie: structure that contains the synthetic data info
    %   .transition_times: vector of times at which promoter state switched
    %   .naive_states: vector of promoter states
    %   .loading_scenarios: DATA STRUCTURE CONTAINING THE FOLLOWING:
    %       .fluo: synthetic trace generated without taking the MS2 loops
    %          into account (poisson arrivals and blocking effects
    %          included)
    %       .fluo_MS2: synthetic trace generated by taking the MS2 loops 
    %              into account (poisson arrivals and blocking effects
    %          included)
    %       .fluo_nn: synthetic trace generated without taking the MS2 
    %                   loops into account and with no Gaussian noise (poisson 
    %                   arrivals and blocking effects included)
    %          
    %       .fluo_MS2_nn: synthetic trace generating by taking the MS2 
    %                       loops into account but with no Gaussian noise 
    %                       (poisson arrivals and blocking effects included)
    %       .fluo_per_rna: calibration value
    %       .fluo_per_rna_effective: effective loading rate (discrete
    %                               effects cause this to be somewhat elevated relative to
    %                               continuous case
    %       .name: title assigned to this scenario
    %       .block_time: time for which promoter is blocked upon Pol II
    %                   arrival
    %       .elongation_time: elongation time for scenario
    %       .fluo_naive: fluo loading for each time step for scenario
    
    % add third state for generation of continuous loading trace
    r_emission_orig = [r_emission 2*r_emission(2)];
        
    % uniformly distributed time points with resolution deltaT 
    % and length seq_length
    times_unif = (1:seq_length) * deltaT;
    
    %generate ref vector of all possible promoter combinations
    p_config_vec = combvec(0:(length(r_emission)-1),0:(length(r_emission)-1));
    state_id_vec = zeros(1,length(p_config_vec));
    for i = 1:length(p_config_vec)
        for j = 1:n_promoters
            state_id_vec(i) = state_id_vec(i) + n_promoters^p_config_vec(j,i);
        end
        state_id_vec(i) = state_id_vec(i) - n_promoters; 
    end    
    unique_states = sort(unique(state_id_vec));
    
    % arrays for storing the naive states, times of transitions and 
    % cumulative fluorescence values during the Gillespie simulation
    naive_states = [];
    p_times = [];
    % duration of the simulated process
    t_max = seq_length * deltaT;
    
    %------------Simulate Sequence of Promoter States---------------------%
    % first state obtained by sampling the initial state pmf
    naive_states(1) = randsample(1:K, 1, true, pi0);
    state_id = unique_states(naive_states(1));
    state_ind = randsample(1:length(state_id_vec), 1, true,(state_id_vec==state_id)/sum(state_id_vec==state_id));
    promoter_config = p_config_vec(:,state_ind);
    
    % assign 0 values to the time and fluo_cum arrays at t = 0
    p_times(1) = 0;
    
    % variable to keep track of the current reaction time
    t = 0;
    
    % indexing variable to keep track of the current transition
    ind = 1;
    % generate a sequence of naive states using the Gillespie algorithm
    while (t < t_max)
        lambda = -R(naive_states(ind),naive_states(ind));
        % randomly draw next jump time
        dt = exprnd(1/lambda);
        t = t + dt;
        rates = R(:,naive_states(ind));
        rates(naive_states(ind)) = 0;
        probs = rates / lambda;
        % draw next state
        ind = ind + 1;
        naive_states(ind) = randsample(1:K, 1, true, probs);
        p_times(ind) = t;
        
        % randomly assign activity states to each promoter given previous state
        % only relevant for degenerate states
        state_id = unique_states(naive_states(ind-1));
        state_ind = randsample(1:length(state_id_vec), 1, true,(state_id_vec==state_id)/sum(state_id_vec==state_id));
        promoter_config = [promoter_config p_config_vec(:,state_ind)];
    end
    % generate gauss noise vector to apply to all versions
    gauss_noise = normrnd(0,noise,1,seq_length);
    
    %Initialze meta struct to store fluo values for individual laoding
    %scenarios
    fluo_trajectories = struct;
    % iterate through scenarios
    for i = 1:length(names)
        % set block time
        block_time = blocking_sizes(i) / elongation_rates(i);
        % if instantaneous initiation assumed, adjust F mRNA calibration
        % accordingly
        if instant_fluo(i) == 1
            f_rna = r_emission(2)*blocking_sizes(i) / elongation_rates(i);
%             warning(['Fluo Per mRNA is being adjusted to: ' num2str(f_rna) ' to maintain consistency with continuous case']);
            arrival_rate = Inf;
        else 
            f_rna = fluo_per_rna(i);
            % calculate polII arrival rate based upon input parameters
            arrival_rate = r_emission(2) / (f_rna - (r_emission(2)*blocking_sizes(i))/elongation_rates(i));
            if arrival_rate < 0
                error('Selected Parameters Imply a Negative PolII Arrival Rate');
            end
        end
        
        %blk time trackers
        t_blk = zeros(n_promoters,1);
        % initialize cumulative fluo
        fluo_cum = zeros(1,length(p_times));
        % store arrival times
        arrival_times = [];
        
        for k = 2:length(p_times)          
            fluo_cum(k) = fluo_cum(k - 1);
            % duration of activity period
            dt = p_times(k) - p_times(k-1);
            for j = 1:n_promoters  
                % first account for holdovers from previous step
                cycle_time = min(dt,t_blk(j));
                t_blk(j) = t_blk(j) - cycle_time;               
                % simulate polII arrivals for specified active window               
                if promoter_config(j,k) > 0
                    while cycle_time < dt
                        % draw nex arrival time
                        p_dt = exprnd(1/arrival_rate);
                        % increment cycle time
                        cycle_time = cycle_time + p_dt;  
                        %if predicted arrival time is within step window
                        %add fluo
                        if cycle_time < dt
                            arrival_times = [arrival_times p_times(k-1)+ cycle_time];
                            fluo_cum(k) = fluo_cum(k) + f_rna;                            
                            cycle_time = cycle_time + block_time;
                            if cycle_time > dt
                                t_blk(j) = cycle_time - dt;                               
                            else
                                t_blk(j) = 0;      
                            end
                        end
                    end
                end
            end
        end
    
        % find the fluorescence at the uniformly distributed points without
        % accounting for the MS2 loops
        fluo_cum_interp = interp1(p_times, fluo_cum, times_unif);
        fluo_cum_interp_shift = [zeros([1, w]), fluo_cum_interp(1:(end-w))];
        fluo = fluo_cum_interp - fluo_cum_interp_shift;
        fluo_MS2 = zeros(1, length(fluo));
        
        % find the fluorescence at the uniformly distributed points taking the
        % MS2 loops into account
        arrival_times = sort(arrival_times);
        for k = 1:seq_length
            t_end = times_unif(k);
            t_start = max([0, t_end - w*deltaT]);

            ind_start_before = find(arrival_times >= t_start);
            if isempty(ind_start_before)
                continue;
            end
            i_start = ind_start_before(1);

            ind_end_before = find(arrival_times <= t_end);
            if isempty(ind_end_before)
                continue;
            end
            i_end = ind_end_before(end);

            times_window = arrival_times(i_start:i_end);

            for g = 1:(length(times_window))

                t2 = t_end - times_window(g);
                if t2 > alpha * deltaT
                    fluo_MS2(k) = fluo_MS2(k) + f_rna;
                else
                    fluo_MS2(k) = fluo_MS2(k) + f_rna * ...
                              t2 / (alpha * deltaT);
                end
            end
        end
        % store fluo loading per time step
        fluo_naive = zeros(1,seq_length);
        for k = 1:seq_length
            arrivals = arrival_times(1==((arrival_times >= (k-1)*deltaT).*(arrival_times < k*deltaT)));
            fluo_naive(k) = length(arrivals)*f_rna;
        end
        % store results
%         display(i)
        fluo_trajectories(i).name = names{i}; 
        fluo_trajectories(i).blk_time = block_time;
        fluo_trajectories(i).fluo_per_rna = f_rna;
        fluo_trajectories(i).arrival_rate = arrival_rate;
        fluo_trajectories(i).elongation_rate = elongation_rates(i);
        fluo_trajectories(i).fluo_nn = fluo;
        fluo_trajectories(i).fluo_MS2_nn = fluo_MS2;
        fluo_trajectories(i).fluo = fluo + gauss_noise;
        fluo_trajectories(i).fluo_MS2 = fluo_MS2 + gauss_noise;
        fluo_trajectories(i).fluo_naive = fluo_naive;
        fluo_trajectories(i).arrival_times = arrival_times;
    end
    
    fluo_naive_continuous = zeros(1,seq_length);
    fluo_MS2_orig = zeros(1,seq_length);
    fluo_orig = zeros(1,seq_length);
    % calculates fluorescense with MS2 for the original
    for k = 1:seq_length
        t_end = times_unif(k);
        t_start = max([0, t_end - w*deltaT]);
        %Mirror the process for single time step
        t_start_single = max([0 , t_end - deltaT]);
        i_start_single= find(p_times <= t_start_single,1,'last');
        
        ind_start_before = find(p_times <= t_start);
        i_start = ind_start_before(end);
        
        ind_end_before = find(p_times <= t_end);
        i_end = ind_end_before(end);
        
        times_window = p_times(i_start:(i_end+1));
        times_window(1) = t_start;
        times_window(end) = t_end;
        
        times_window_single = p_times(i_start_single:(i_end+1));
        times_window_single(1) = t_start_single;
        times_window_single(end) = t_end;
        
        naive_window = naive_states(i_start:(i_end+1));
        single_window = naive_states(i_start_single:(i_end+1));
        for i = 1:(length(naive_window)-1)
            
            t1 = t_end - times_window(i+1);
            t2 = t_end - times_window(i);
            fluo_MS2_orig(k) = fluo_MS2_orig(k) + r_emission_orig(naive_window(i)) * ...
                          ms2_loading_coeff_integral(alpha, w, deltaT, t1, t2);
            
        end
        for j = 1:(length(single_window)-1)
            t1 = t_end - times_window_single(j+1);
            t2 = t_end - times_window_single(j);
            fluo_naive_continuous(k) = fluo_naive_continuous(k) +  ...
                r_emission_orig(single_window(j))*(t2-t1);
        end
    end
    
    fluo_trajectories(length(names)+1).name = 'continuous'; 
    fluo_trajectories(length(names)+1).blk_time = nan;
    fluo_trajectories(length(names)+1).fluo_per_rna = nan;
    fluo_trajectories(length(names)+1).arrival_rate = nan;
    fluo_trajectories(length(names)+1).elongation_rate = nan;
    fluo_trajectories(length(names)+1).fluo_nn = fluo_orig;
    fluo_trajectories(length(names)+1).fluo_MS2_nn = fluo_MS2_orig;
    fluo_trajectories(length(names)+1).fluo = fluo_orig + gauss_noise;
    fluo_trajectories(length(names)+1).fluo_MS2 = fluo_MS2_orig + gauss_noise;
    fluo_trajectories(length(names)+1).fluo_naive = fluo_naive_continuous;
    
    % correct fluo_per_rna for instant arrivals
    mean_continuous = mean(fluo_MS2_orig);
    for i = 1:length(names)        
        mean_fluo = mean(fluo_trajectories(i).fluo_MS2_nn);
        factor = mean_continuous / mean_fluo;
        fluo_trajectories(i).fluo_per_rna_effective = fluo_trajectories(i).fluo_per_rna * factor^-1;
        if adjust_means == 1
            fluo_trajectories(i).fluo_MS2_nn = fluo_trajectories(i).fluo_MS2_nn * factor;
            fluo_trajectories(i).fluo_MS2 = fluo_trajectories(i).fluo_MS2 * factor;
            fluo_trajectories(i).fluo_nn = fluo_trajectories(i).fluo_nn * factor;
            fluo_trajectories(i).fluo = fluo_trajectories(i).fluo * factor;
        end
    end
    % the output structure
    gillespie = struct('loading_scenarios', fluo_trajectories, ...
        'transition_times', p_times, 'naive_states', naive_states ...
         );